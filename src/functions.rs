// This file is part of dpdk-sys. It is subject to the license terms in the COPYRIGHT file found in the top-level directory of this distribution and at https://raw.githubusercontent.com/lemonrock/dpdk-sys/master/COPYRIGHT. No part of dpdk-sys, including this file, may be copied, modified, propagated, or distributed except according to the terms contained in the COPYRIGHT file.
// Copyright Â© 2016 The developers of dpdk-sys. See the COPYRIGHT file in the top-level directory of this distribution and at https://raw.githubusercontent.com/lemonrock/dpdk-sys/master/COPYRIGHT.


extern "C"
{
	pub fn cirbuf_add_buf_head(cbuf: *mut cirbuf, c: *const c_char, n: c_uint) -> c_int;
	pub fn cirbuf_add_buf_tail(cbuf: *mut cirbuf, c: *const c_char, n: c_uint) -> c_int;
	pub fn cirbuf_add_head(cbuf: *mut cirbuf, c: c_char);
	pub fn cirbuf_add_head_safe(cbuf: *mut cirbuf, c: c_char) -> c_int;
	pub fn cirbuf_add_tail(cbuf: *mut cirbuf, c: c_char);
	pub fn cirbuf_add_tail_safe(cbuf: *mut cirbuf, c: c_char) -> c_int;
	pub fn cirbuf_align_left(cbuf: *mut cirbuf) -> c_int;
	pub fn cirbuf_align_right(cbuf: *mut cirbuf) -> c_int;
	pub fn cirbuf_del_buf_head(cbuf: *mut cirbuf, size: c_uint) -> c_int;
	pub fn cirbuf_del_buf_tail(cbuf: *mut cirbuf, size: c_uint) -> c_int;
	pub fn cirbuf_del_head(cbuf: *mut cirbuf);
	pub fn cirbuf_del_head_safe(cbuf: *mut cirbuf) -> c_int;
	pub fn cirbuf_del_tail(cbuf: *mut cirbuf);
	pub fn cirbuf_del_tail_safe(cbuf: *mut cirbuf) -> c_int;
	pub fn cirbuf_get_buf_head(cbuf: *mut cirbuf, c: *mut c_char, size: c_uint) -> c_int;
	pub fn cirbuf_get_buf_tail(cbuf: *mut cirbuf, c: *mut c_char, size: c_uint) -> c_int;
	pub fn cirbuf_get_head(cbuf: *mut cirbuf) -> c_char;
	pub fn cirbuf_get_tail(cbuf: *mut cirbuf) -> c_char;
	pub fn cirbuf_init(cbuf: *mut cirbuf, buf: *mut c_char, start: c_uint, maxlen: c_uint) -> c_int;
	pub fn cmdline_complete(cl: *mut cmdline, buf: *const c_char, state: *mut c_int, dst: *mut c_char, size: c_uint) -> c_int;
	pub fn cmdline_complete_get_elt_string(tk: *mut cmdline_parse_token_hdr_t, idx: c_int, dstbuf: *mut c_char, size: c_uint) -> c_int;
	pub fn cmdline_complete_get_nb_string(tk: *mut cmdline_parse_token_hdr_t) -> c_int;
	pub fn cmdline_file_new(ctx: *mut cmdline_parse_ctx_t, prompt: *const c_char, path: *const c_char) -> *mut cmdline;
	pub fn cmdline_free(cl: *mut cmdline);
	pub fn cmdline_get_help_etheraddr(tk: *mut cmdline_parse_token_hdr_t, dstbuf: *mut c_char, size: c_uint) -> c_int;
	pub fn cmdline_get_help_ipaddr(tk: *mut cmdline_parse_token_hdr_t, dstbuf: *mut c_char, size: c_uint) -> c_int;
	pub fn cmdline_get_help_num(tk: *mut cmdline_parse_token_hdr_t, dstbuf: *mut c_char, size: c_uint) -> c_int;
	pub fn cmdline_get_help_portlist(tk: *mut cmdline_parse_token_hdr_t, dstbuf: *mut c_char, size: c_uint) -> c_int;
	pub fn cmdline_get_help_string(tk: *mut cmdline_parse_token_hdr_t, dstbuf: *mut c_char, size: c_uint) -> c_int;
	pub fn cmdline_in(cl: *mut cmdline, buf: *const c_char, size: c_int) -> c_int;
	pub fn cmdline_interact(cl: *mut cmdline);
	pub fn cmdline_isendofcommand(c: c_char) -> c_int;
	pub fn cmdline_isendoftoken(c: c_char) -> c_int;
	pub fn cmdline_new(ctx: *mut cmdline_parse_ctx_t, prompt: *const c_char, s_in: c_int, s_out: c_int) -> *mut cmdline;
	pub fn cmdline_parse(cl: *mut cmdline, buf: *const c_char) -> c_int;
	pub fn cmdline_parse_etheraddr(tk: *mut cmdline_parse_token_hdr_t, srcbuf: *const c_char, res: *mut c_void, ressize: c_uint) -> c_int;
	pub fn cmdline_parse_ipaddr(tk: *mut cmdline_parse_token_hdr_t, srcbuf: *const c_char, res: *mut c_void, ressize: c_uint) -> c_int;
	pub fn cmdline_parse_num(tk: *mut cmdline_parse_token_hdr_t, srcbuf: *const c_char, res: *mut c_void, ressize: c_uint) -> c_int;
	pub fn cmdline_parse_portlist(tk: *mut cmdline_parse_token_hdr_t, srcbuf: *const c_char, res: *mut c_void, ressize: c_uint) -> c_int;
	pub fn cmdline_parse_string(tk: *mut cmdline_parse_token_hdr_t, srcbuf: *const c_char, res: *mut c_void, ressize: c_uint) -> c_int;
	pub fn cmdline_poll(cl: *mut cmdline) -> c_int;
	pub fn cmdline_printf(cl: *const cmdline, fmt: *const c_char, ...);
	pub fn cmdline_quit(cl: *mut cmdline);
	pub fn cmdline_set_prompt(cl: *mut cmdline, prompt: *const c_char);
	pub fn cmdline_stdin_exit(cl: *mut cmdline);
	pub fn cmdline_stdin_new(ctx: *mut cmdline_parse_ctx_t, prompt: *const c_char) -> *mut cmdline;
	pub fn cmdline_write_char(rdl: *mut rdline, c: c_char) -> c_int;
	pub fn eth_dev_null_create(name: *const c_char, numa_node: c_uint, packet_size: c_uint, packet_copy: c_uint) -> c_int;
	pub fn rdline_add_history(rdl: *mut rdline, buf: *const c_char) -> c_int;
	pub fn rdline_char_in(rdl: *mut rdline, c: c_char) -> c_int;
	pub fn rdline_clear_history(rdl: *mut rdline);
	pub fn rdline_get_buffer(rdl: *mut rdline) -> *const c_char;
	pub fn rdline_get_history_item(rdl: *mut rdline, i: c_uint) -> *mut c_char;
	pub fn rdline_init(rdl: *mut rdline, write_char: rdline_write_char_t, validate: rdline_validate_t, complete: rdline_complete_t) -> c_int;
	pub fn rdline_newline(rdl: *mut rdline, prompt: *const c_char);
	pub fn rdline_quit(rdl: *mut rdline);
	pub fn rdline_redisplay(rdl: *mut rdline);
	pub fn rdline_reset(rdl: *mut rdline);
	pub fn rdline_restart(rdl: *mut rdline);
	pub fn rdline_stop(rdl: *mut rdline);
	pub fn rte_acl_add_rules(ctx: *mut rte_acl_ctx, rules: *const rte_acl_rule, num: uint32_t) -> c_int;
	pub fn rte_acl_build(ctx: *mut rte_acl_ctx, cfg: *const rte_acl_config) -> c_int;
	pub fn rte_acl_classify(ctx: *const rte_acl_ctx, data: *mut *const uint8_t, results: *mut uint32_t, num: uint32_t, categories: uint32_t) -> c_int;
	pub fn rte_acl_classify_alg(ctx: *const rte_acl_ctx, data: *mut *const uint8_t, results: *mut uint32_t, num: uint32_t, categories: uint32_t, alg: rte_acl_classify_alg) -> c_int;
	pub fn rte_acl_create(param: *const rte_acl_param) -> *mut rte_acl_ctx;
	pub fn rte_acl_dump(ctx: *const rte_acl_ctx);
	pub fn rte_acl_find_existing(name: *const c_char) -> *mut rte_acl_ctx;
	pub fn rte_acl_free(ctx: *mut rte_acl_ctx);
	pub fn rte_acl_list_dump();
	pub fn rte_acl_reset(ctx: *mut rte_acl_ctx);
	pub fn rte_acl_reset_rules(ctx: *mut rte_acl_ctx);
	pub fn rte_acl_set_ctx_classify(ctx: *mut rte_acl_ctx, alg: rte_acl_classify_alg) -> c_int;
	pub fn rte_approx(alpha: f64, d: f64, p: *mut uint32_t, q: *mut uint32_t) -> c_int;
	pub fn rte_calloc(type_: *const c_char, num: size_t, size: size_t, align: c_uint) -> *mut c_void;
	pub fn rte_calloc_socket(type_: *const c_char, num: size_t, size: size_t, align: c_uint, socket: c_int) -> *mut c_void;
	pub fn rte_cfgfile_close(cfg: *mut rte_cfgfile) -> c_int;
	pub fn rte_cfgfile_get_entry(cfg: *mut rte_cfgfile, sectionname: *const c_char, entryname: *const c_char) -> *const c_char;
	pub fn rte_cfgfile_has_entry(cfg: *mut rte_cfgfile, sectionname: *const c_char, entryname: *const c_char) -> c_int;
	pub fn rte_cfgfile_has_section(cfg: *mut rte_cfgfile, sectionname: *const c_char) -> c_int;
	pub fn rte_cfgfile_load(filename: *const c_char, flags: c_int) -> *mut rte_cfgfile;
	pub fn rte_cfgfile_num_sections(cfg: *mut rte_cfgfile, sec_name: *const c_char, length: size_t) -> c_int;
	pub fn rte_cfgfile_section_entries(cfg: *mut rte_cfgfile, sectionname: *const c_char, entries: *mut rte_cfgfile_entry, max_entries: c_int) -> c_int;
	pub fn rte_cfgfile_section_entries_by_index(cfg: *mut rte_cfgfile, index: c_int, sectionname: *mut c_char, entries: *mut rte_cfgfile_entry, max_entries: c_int) -> c_int;
	pub fn rte_cfgfile_section_num_entries(cfg: *mut rte_cfgfile, sectionname: *const c_char) -> c_int;
	pub fn rte_cfgfile_sections(cfg: *mut rte_cfgfile, sections: *mut *mut c_char, max_sections: c_int) -> c_int;
	pub fn rte_cpu_check_supported();
	pub fn rte_cpu_get_flag_enabled(feature: rte_cpu_flag_t) -> c_int;
	pub fn rte_cpu_get_flag_name(feature: rte_cpu_flag_t) -> *const c_char;
	pub fn rte_crypto_op_pool_create(name: *const c_char, type_: rte_crypto_op_type, nb_elts: c_uint, cache_size: c_uint, priv_size: uint16_t, socket_id: c_int) -> *mut rte_mempool;
	pub fn rte_ctrlmbuf_init(mp: *mut rte_mempool, opaque_arg: *mut c_void, m: *mut c_void, i: c_uint);
	pub fn rte_delay_us(us: c_uint);
	pub fn rte_distributor_clear_returns(d: *mut rte_distributor);
	pub fn rte_distributor_create(name: *const c_char, socket_id: c_uint, num_workers: c_uint) -> *mut rte_distributor;
	pub fn rte_distributor_flush(d: *mut rte_distributor) -> c_int;
	pub fn rte_distributor_get_pkt(d: *mut rte_distributor, worker_id: c_uint, oldpkt: *mut rte_mbuf) -> *mut rte_mbuf;
	pub fn rte_distributor_poll_pkt(d: *mut rte_distributor, worker_id: c_uint) -> *mut rte_mbuf;
	pub fn rte_distributor_process(d: *mut rte_distributor, mbufs: *mut *mut rte_mbuf, num_mbufs: c_uint) -> c_int;
	pub fn rte_distributor_request_pkt(d: *mut rte_distributor, worker_id: c_uint, oldpkt: *mut rte_mbuf);
	pub fn rte_distributor_return_pkt(d: *mut rte_distributor, worker_id: c_uint, mbuf: *mut rte_mbuf) -> c_int;
	pub fn rte_distributor_returned_pkts(d: *mut rte_distributor, mbufs: *mut *mut rte_mbuf, max_mbufs: c_uint) -> c_int;
	pub fn rte_dump_physmem_layout(f: *mut FILE);
	pub fn rte_dump_registers();
	pub fn rte_dump_stack();
	pub fn rte_dump_tailq(f: *mut FILE);
	pub fn rte_eal_alarm_cancel(cb_fn: rte_eal_alarm_callback, cb_arg: *mut c_void) -> c_int;
	pub fn rte_eal_alarm_set(us: uint64_t, cb: rte_eal_alarm_callback, cb_arg: *mut c_void) -> c_int;
	pub fn rte_eal_dev_init() -> c_int;
	pub fn rte_eal_driver_register(driver: *mut rte_driver);
	pub fn rte_eal_driver_unregister(driver: *mut rte_driver);
	pub fn rte_eal_get_configuration() -> *mut rte_config;
	pub fn rte_eal_get_lcore_state(slave_id: c_uint) -> rte_lcore_state_t;
	pub fn rte_eal_get_physmem_layout() -> *const rte_memseg;
	pub fn rte_eal_get_physmem_size() -> uint64_t;
	pub fn rte_eal_has_hugepages() -> c_int;
	pub fn rte_eal_init(argc: c_int, argv: *mut *mut c_char) -> c_int;
	pub fn rte_eal_iopl_init() -> c_int;
	pub fn rte_eal_lcore_role(lcore_id: c_uint) -> rte_lcore_role_t;
	pub fn rte_eal_mp_remote_launch(f: lcore_function_t, arg: *mut c_void, call_master: rte_rmt_call_master_t) -> c_int;
	pub fn rte_eal_mp_wait_lcore();
	pub fn rte_eal_primary_proc_alive(config_file_path: *const c_char) -> c_int;
	pub fn rte_eal_process_type() -> rte_proc_type_t;
	pub fn rte_eal_remote_launch(f: lcore_function_t, arg: *mut c_void, slave_id: c_uint) -> c_int;
	pub fn rte_eal_tailq_lookup(name: *const c_char) -> *mut rte_tailq_head;
	pub fn rte_eal_tailq_register(t: *mut rte_tailq_elem) -> c_int;
	pub fn rte_eal_vdev_init(name: *const c_char, args: *const c_char) -> c_int;
	pub fn rte_eal_vdev_uninit(name: *const c_char) -> c_int;
	pub fn rte_eal_wait_lcore(slave_id: c_uint) -> c_int;
	pub fn rte_epoll_ctl(epfd: c_int, op: c_int, fd: c_int, event: *mut rte_epoll_event) -> c_int;
	pub fn rte_epoll_wait(epfd: c_int, events: *mut rte_epoll_event, maxevents: c_int, timeout: c_int) -> c_int;
	pub fn rte_eth_bond_active_slaves_get(bonded_port_id: uint8_t, slaves: *mut uint8_t, len: uint8_t) -> c_int;
	pub fn rte_eth_bond_create(name: *const c_char, mode: uint8_t, socket_id: uint8_t) -> c_int;
	pub fn rte_eth_bond_free(name: *const c_char) -> c_int;
	pub fn rte_eth_bond_link_down_prop_delay_get(bonded_port_id: uint8_t) -> c_int;
	pub fn rte_eth_bond_link_down_prop_delay_set(bonded_port_id: uint8_t, delay_ms: uint32_t) -> c_int;
	pub fn rte_eth_bond_link_monitoring_get(bonded_port_id: uint8_t) -> c_int;
	pub fn rte_eth_bond_link_monitoring_set(bonded_port_id: uint8_t, internal_ms: uint32_t) -> c_int;
	pub fn rte_eth_bond_link_up_prop_delay_get(bonded_port_id: uint8_t) -> c_int;
	pub fn rte_eth_bond_link_up_prop_delay_set(bonded_port_id: uint8_t, delay_ms: uint32_t) -> c_int;
	pub fn rte_eth_bond_mac_address_reset(bonded_port_id: uint8_t) -> c_int;
	pub fn rte_eth_bond_mac_address_set(bonded_port_id: uint8_t, mac_addr: *mut ether_addr) -> c_int;
	pub fn rte_eth_bond_mode_get(bonded_port_id: uint8_t) -> c_int;
	pub fn rte_eth_bond_mode_set(bonded_port_id: uint8_t, mode: uint8_t) -> c_int;
	pub fn rte_eth_bond_primary_get(bonded_port_id: uint8_t) -> c_int;
	pub fn rte_eth_bond_primary_set(bonded_port_id: uint8_t, slave_port_id: uint8_t) -> c_int;
	pub fn rte_eth_bond_slave_add(bonded_port_id: uint8_t, slave_port_id: uint8_t) -> c_int;
	pub fn rte_eth_bond_slave_remove(bonded_port_id: uint8_t, slave_port_id: uint8_t) -> c_int;
	pub fn rte_eth_bond_slaves_get(bonded_port_id: uint8_t, slaves: *mut uint8_t, len: uint8_t) -> c_int;
	pub fn rte_eth_bond_xmit_policy_get(bonded_port_id: uint8_t) -> c_int;
	pub fn rte_eth_bond_xmit_policy_set(bonded_port_id: uint8_t, policy: uint8_t) -> c_int;
	pub fn rte_eth_from_ring(r: *mut rte_ring) -> c_int;
	pub fn rte_eth_from_rings(name: *const c_char, rx_queues: *mut *mut rte_ring, nb_rx_queues: c_uint, tx_queues: *mut *mut rte_ring, nb_tx_queues: c_uint, numa_node: c_uint) -> c_int;
	pub fn rte_eth_vhost_feature_disable(feature_mask: uint64_t) -> c_int;
	pub fn rte_eth_vhost_feature_enable(feature_mask: uint64_t) -> c_int;
	pub fn rte_eth_vhost_feature_get() -> uint64_t;
	pub fn rte_eth_vhost_get_queue_event(port_id: uint8_t, event: *mut rte_eth_vhost_queue_event) -> c_int;
	pub fn rte_exit(exit_code: c_int, format: *const c_char, ...);
	pub fn rte_fbk_hash_create(params: *const rte_fbk_hash_params) -> *mut rte_fbk_hash_table;
	pub fn rte_fbk_hash_find_existing(name: *const c_char) -> *mut rte_fbk_hash_table;
	pub fn rte_fbk_hash_free(ht: *mut rte_fbk_hash_table);
	pub fn rte_free(ptr: *mut c_void);
	pub fn rte_get_log_level() -> uint32_t;
	pub fn rte_get_log_type() -> uint32_t;
	pub fn rte_get_rx_ol_flag_name(mask: uint64_t) -> *const c_char;
	pub fn rte_get_tsc_hz() -> uint64_t;
	pub fn rte_get_tx_ol_flag_name(mask: uint64_t) -> *const c_char;
	pub fn rte_hash_add_key(h: *const rte_hash, key: *const c_void) -> int32_t;
	pub fn rte_hash_add_key_data(h: *const rte_hash, key: *const c_void, data: *mut c_void) -> c_int;
	pub fn rte_hash_add_key_with_hash(h: *const rte_hash, key: *const c_void, sig: hash_sig_t) -> int32_t;
	pub fn rte_hash_add_key_with_hash_data(h: *const rte_hash, key: *const c_void, sig: hash_sig_t, data: *mut c_void) -> int32_t;
	pub fn rte_hash_create(params: *const rte_hash_parameters) -> *mut rte_hash;
	pub fn rte_hash_del_key(h: *const rte_hash, key: *const c_void) -> int32_t;
	pub fn rte_hash_del_key_with_hash(h: *const rte_hash, key: *const c_void, sig: hash_sig_t) -> int32_t;
	pub fn rte_hash_find_existing(name: *const c_char) -> *mut rte_hash;
	pub fn rte_hash_free(h: *mut rte_hash);
	pub fn rte_hash_get_key_with_position(h: *const rte_hash, position: int32_t, key: *mut *mut c_void) -> c_int;
	pub fn rte_hash_hash(h: *const rte_hash, key: *const c_void) -> hash_sig_t;
	pub fn rte_hash_iterate(h: *const rte_hash, key: *mut *const c_void, data: *mut *mut c_void, next: *mut uint32_t) -> int32_t;
	pub fn rte_hash_lookup(h: *const rte_hash, key: *const c_void) -> int32_t;
	pub fn rte_hash_lookup_bulk(h: *const rte_hash, keys: *mut *const c_void, num_keys: uint32_t, positions: *mut int32_t) -> c_int;
	pub fn rte_hash_lookup_bulk_data(h: *const rte_hash, keys: *mut *const c_void, num_keys: uint32_t, hit_mask: *mut uint64_t, data: *mut *mut c_void) -> c_int;
	pub fn rte_hash_lookup_data(h: *const rte_hash, key: *const c_void, data: *mut *mut c_void) -> c_int;
	pub fn rte_hash_lookup_with_hash(h: *const rte_hash, key: *const c_void, sig: hash_sig_t) -> int32_t;
	pub fn rte_hash_lookup_with_hash_data(h: *const rte_hash, key: *const c_void, sig: hash_sig_t, data: *mut *mut c_void) -> c_int;
	pub fn rte_hash_reset(h: *mut rte_hash);
	pub fn rte_hash_set_cmp_func(h: *mut rte_hash, func: rte_hash_cmp_eq_t);
	pub fn rte_hexdump(f: *mut FILE, title: *const c_char, buf: *const c_void, len: c_uint);
	pub fn rte_intr_allow_others(intr_handle: *mut rte_intr_handle) -> c_int;
	pub fn rte_intr_callback_register(intr_handle: *mut rte_intr_handle, cb: rte_intr_callback_fn, cb_arg: *mut c_void) -> c_int;
	pub fn rte_intr_callback_unregister(intr_handle: *mut rte_intr_handle, cb: rte_intr_callback_fn, cb_arg: *mut c_void) -> c_int;
	pub fn rte_intr_cap_multiple(intr_handle: *mut rte_intr_handle) -> c_int;
	pub fn rte_intr_disable(intr_handle: *mut rte_intr_handle) -> c_int;
	pub fn rte_intr_dp_is_en(intr_handle: *mut rte_intr_handle) -> c_int;
	pub fn rte_intr_efd_disable(intr_handle: *mut rte_intr_handle);
	pub fn rte_intr_efd_enable(intr_handle: *mut rte_intr_handle, nb_efd: uint32_t) -> c_int;
	pub fn rte_intr_enable(intr_handle: *mut rte_intr_handle) -> c_int;
	pub fn rte_intr_rx_ctl(intr_handle: *mut rte_intr_handle, epfd: c_int, op: c_int, vec: c_uint, data: *mut c_void) -> c_int;
	pub fn rte_intr_tls_epfd() -> c_int;
	pub fn rte_ip_frag_free_death_row(dr: *mut rte_ip_frag_death_row, prefetch: uint32_t);
	pub fn rte_ip_frag_table_create(bucket_num: uint32_t, bucket_entries: uint32_t, max_entries: uint32_t, max_cycles: uint64_t, socket_id: c_int) -> *mut rte_ip_frag_tbl;
	pub fn rte_ip_frag_table_statistics_dump(f: *mut FILE, tbl: *const rte_ip_frag_tbl);
	pub fn rte_ipv4_frag_reassemble_packet(tbl: *mut rte_ip_frag_tbl, dr: *mut rte_ip_frag_death_row, mb: *mut rte_mbuf, tms: uint64_t, ip_hdr: *mut ipv4_hdr) -> *mut rte_mbuf;
	pub fn rte_ipv4_fragment_packet(pkt_in: *mut rte_mbuf, pkts_out: *mut *mut rte_mbuf, nb_pkts_out: uint16_t, mtu_size: uint16_t, pool_direct: *mut rte_mempool, pool_indirect: *mut rte_mempool) -> int32_t;
	pub fn rte_ipv6_frag_reassemble_packet(tbl: *mut rte_ip_frag_tbl, dr: *mut rte_ip_frag_death_row, mb: *mut rte_mbuf, tms: uint64_t, ip_hdr: *mut ipv6_hdr, frag_hdr: *mut ipv6_extension_fragment) -> *mut rte_mbuf;
	pub fn rte_ipv6_fragment_packet(pkt_in: *mut rte_mbuf, pkts_out: *mut *mut rte_mbuf, nb_pkts_out: uint16_t, mtu_size: uint16_t, pool_direct: *mut rte_mempool, pool_indirect: *mut rte_mempool) -> int32_t;
	pub fn rte_jobstats_abort(job: *mut rte_jobstats) -> c_int;
	pub fn rte_jobstats_context_finish(ctx: *mut rte_jobstats_context);
	pub fn rte_jobstats_context_init(ctx: *mut rte_jobstats_context) -> c_int;
	pub fn rte_jobstats_context_reset(ctx: *mut rte_jobstats_context);
	pub fn rte_jobstats_context_start(ctx: *mut rte_jobstats_context);
	pub fn rte_jobstats_finish(job: *mut rte_jobstats, job_value: int64_t) -> c_int;
	pub fn rte_jobstats_init(job: *mut rte_jobstats, name: *const c_char, min_period: uint64_t, max_period: uint64_t, initial_period: uint64_t, target: int64_t) -> c_int;
	pub fn rte_jobstats_reset(job: *mut rte_jobstats);
	pub fn rte_jobstats_set_max(job: *mut rte_jobstats, period: uint64_t);
	pub fn rte_jobstats_set_min(job: *mut rte_jobstats, period: uint64_t);
	pub fn rte_jobstats_set_period(job: *mut rte_jobstats, period: uint64_t, saturate: uint8_t);
	pub fn rte_jobstats_set_target(job: *mut rte_jobstats, target: int64_t);
	pub fn rte_jobstats_set_update_period_function(job: *mut rte_jobstats, update_period_cb: rte_job_update_period_cb_t);
	pub fn rte_jobstats_start(ctx: *mut rte_jobstats_context, job: *mut rte_jobstats) -> c_int;
	pub fn rte_keepalive_create(callback: rte_keepalive_failure_callback_t, data: *mut c_void) -> *mut rte_keepalive;
	pub fn rte_keepalive_dispatch_pings(ptr_timer: *mut c_void, ptr_data: *mut c_void);
	pub fn rte_keepalive_mark_alive(keepcfg: *mut rte_keepalive);
	pub fn rte_keepalive_mark_sleep(keepcfg: *mut rte_keepalive);
	pub fn rte_keepalive_register_core(keepcfg: *mut rte_keepalive, id_core: c_int);
	pub fn rte_keepalive_register_relay_callback(keepcfg: *mut rte_keepalive, callback: rte_keepalive_relay_callback_t, data: *mut c_void);
	pub fn rte_kvargs_count(kvlist: *const rte_kvargs, key_match: *const c_char) -> c_uint;
	pub fn rte_kvargs_free(kvlist: *mut rte_kvargs);
	pub fn rte_kvargs_parse(args: *const c_char, valid_keys: *mut *const c_char) -> *mut rte_kvargs;
	pub fn rte_kvargs_process(kvlist: *const rte_kvargs, key_match: *const c_char, handler: arg_handler_t, opaque_arg: *mut c_void) -> c_int;
	pub fn rte_log(level: uint32_t, logtype: uint32_t, format: *const c_char, ...) -> c_int;
	pub fn rte_log_cur_msg_loglevel() -> c_int;
	pub fn rte_log_cur_msg_logtype() -> c_int;
	pub fn rte_lpm6_add(lpm: *mut rte_lpm6, ip: *mut uint8_t, depth: uint8_t, next_hop: uint8_t) -> c_int;
	pub fn rte_lpm6_create(name: *const c_char, socket_id: c_int, config: *const rte_lpm6_config) -> *mut rte_lpm6;
	pub fn rte_lpm6_delete(lpm: *mut rte_lpm6, ip: *mut uint8_t, depth: uint8_t) -> c_int;
	pub fn rte_lpm6_delete_all(lpm: *mut rte_lpm6);
	pub fn rte_lpm6_delete_bulk_func(lpm: *mut rte_lpm6, ips: *mut [uint8_t; 16usize], depths: *mut uint8_t, n: c_uint) -> c_int;
	pub fn rte_lpm6_find_existing(name: *const c_char) -> *mut rte_lpm6;
	pub fn rte_lpm6_free(lpm: *mut rte_lpm6);
	pub fn rte_lpm6_is_rule_present(lpm: *mut rte_lpm6, ip: *mut uint8_t, depth: uint8_t, next_hop: *mut uint8_t) -> c_int;
	pub fn rte_lpm6_lookup(lpm: *const rte_lpm6, ip: *mut uint8_t, next_hop: *mut uint8_t) -> c_int;
	pub fn rte_lpm6_lookup_bulk_func(lpm: *const rte_lpm6, ips: *mut [uint8_t; 16usize], next_hops: *mut int16_t, n: c_uint) -> c_int;
	pub fn rte_lpm_add(lpm: *mut rte_lpm, ip: uint32_t, depth: uint8_t, next_hop: uint32_t) -> c_int;
	pub fn rte_lpm_add_v1604(lpm: *mut rte_lpm, ip: uint32_t, depth: uint8_t, next_hop: uint32_t) -> c_int;
	pub fn rte_lpm_add_v20(lpm: *mut rte_lpm_v20, ip: uint32_t, depth: uint8_t, next_hop: uint8_t) -> c_int;
	pub fn rte_lpm_create(name: *const c_char, socket_id: c_int, config: *const rte_lpm_config) -> *mut rte_lpm;
	pub fn rte_lpm_create_v1604(name: *const c_char, socket_id: c_int, config: *const rte_lpm_config) -> *mut rte_lpm;
	pub fn rte_lpm_create_v20(name: *const c_char, socket_id: c_int, max_rules: c_int, flags: c_int) -> *mut rte_lpm_v20;
	pub fn rte_lpm_delete(lpm: *mut rte_lpm, ip: uint32_t, depth: uint8_t) -> c_int;
	pub fn rte_lpm_delete_all(lpm: *mut rte_lpm);
	pub fn rte_lpm_delete_all_v1604(lpm: *mut rte_lpm);
	pub fn rte_lpm_delete_all_v20(lpm: *mut rte_lpm_v20);
	pub fn rte_lpm_delete_v1604(lpm: *mut rte_lpm, ip: uint32_t, depth: uint8_t) -> c_int;
	pub fn rte_lpm_delete_v20(lpm: *mut rte_lpm_v20, ip: uint32_t, depth: uint8_t) -> c_int;
	pub fn rte_lpm_find_existing(name: *const c_char) -> *mut rte_lpm;
	pub fn rte_lpm_find_existing_v1604(name: *const c_char) -> *mut rte_lpm;
	pub fn rte_lpm_find_existing_v20(name: *const c_char) -> *mut rte_lpm_v20;
	pub fn rte_lpm_free(lpm: *mut rte_lpm);
	pub fn rte_lpm_free_v1604(lpm: *mut rte_lpm);
	pub fn rte_lpm_free_v20(lpm: *mut rte_lpm_v20);
	pub fn rte_lpm_is_rule_present(lpm: *mut rte_lpm, ip: uint32_t, depth: uint8_t, next_hop: *mut uint32_t) -> c_int;
	pub fn rte_lpm_is_rule_present_v1604(lpm: *mut rte_lpm, ip: uint32_t, depth: uint8_t, next_hop: *mut uint32_t) -> c_int;
	pub fn rte_lpm_is_rule_present_v20(lpm: *mut rte_lpm_v20, ip: uint32_t, depth: uint8_t, next_hop: *mut uint8_t) -> c_int;
	pub fn rte_malloc(type_: *const c_char, size: size_t, align: c_uint) -> *mut c_void;
	pub fn rte_malloc_dump_stats(f: *mut FILE, type_: *const c_char);
	pub fn rte_malloc_get_socket_stats(socket: c_int, socket_stats: *mut rte_malloc_socket_stats) -> c_int;
	pub fn rte_malloc_set_limit(type_: *const c_char, max: size_t) -> c_int;
	pub fn rte_malloc_socket(type_: *const c_char, size: size_t, align: c_uint, socket: c_int) -> *mut c_void;
	pub fn rte_malloc_validate(ptr: *const c_void, size: *mut size_t) -> c_int;
	pub fn rte_malloc_virt2phy(addr: *const c_void) -> phys_addr_t;
	pub fn rte_mbuf_sanity_check(m: *const rte_mbuf, is_header: c_int);
	pub fn rte_mem_lock_page(virt: *const c_void) -> c_int;
	pub fn rte_mem_virt2phy(virt: *const c_void) -> phys_addr_t;
	pub fn rte_memdump(f: *mut FILE, title: *const c_char, buf: *const c_void, len: c_uint);
	pub fn rte_memory_get_nchannel() -> c_uint;
	pub fn rte_memory_get_nrank() -> c_uint;
	pub fn rte_mempool_audit(mp: *mut rte_mempool);
	pub fn rte_mempool_avail_count(mp: *const rte_mempool) -> c_uint;
	pub fn rte_mempool_cache_create(size: uint32_t, socket_id: c_int) -> *mut rte_mempool_cache;
	pub fn rte_mempool_cache_free(cache: *mut rte_mempool_cache);
	pub fn rte_mempool_calc_obj_size(elt_size: uint32_t, flags: uint32_t, sz: *mut rte_mempool_objsz) -> uint32_t;
	pub fn rte_mempool_check_cookies(mp: *const rte_mempool, obj_table_const: *const *mut c_void, n: c_uint, free: c_int);
	pub fn rte_mempool_count(mp: *const rte_mempool) -> c_uint;
	pub fn rte_mempool_create(name: *const c_char, n: c_uint, elt_size: c_uint, cache_size: c_uint, private_data_size: c_uint, mp_init: rte_mempool_ctor_t, mp_init_arg: *mut c_void, obj_init: rte_mempool_obj_cb_t, obj_init_arg: *mut c_void, socket_id: c_int, flags: c_uint) -> *mut rte_mempool;
	pub fn rte_mempool_create_empty(name: *const c_char, n: c_uint, elt_size: c_uint, cache_size: c_uint, private_data_size: c_uint, socket_id: c_int, flags: c_uint) -> *mut rte_mempool;
	pub fn rte_mempool_dump(f: *mut FILE, mp: *mut rte_mempool);
	pub fn rte_mempool_free(mp: *mut rte_mempool);
	pub fn rte_mempool_in_use_count(mp: *const rte_mempool) -> c_uint;
	pub fn rte_mempool_list_dump(f: *mut FILE);
	pub fn rte_mempool_lookup(name: *const c_char) -> *mut rte_mempool;
	pub fn rte_mempool_mem_iter(mp: *mut rte_mempool, mem_cb: rte_mempool_mem_cb_t, mem_cb_arg: *mut c_void) -> uint32_t;
	pub fn rte_mempool_obj_iter(mp: *mut rte_mempool, obj_cb: rte_mempool_obj_cb_t, obj_cb_arg: *mut c_void) -> uint32_t;
	pub fn rte_mempool_ops_alloc(mp: *mut rte_mempool) -> c_int;
	pub fn rte_mempool_ops_free(mp: *mut rte_mempool);
	pub fn rte_mempool_ops_get_count(mp: *const rte_mempool) -> c_uint;
	pub fn rte_mempool_populate_anon(mp: *mut rte_mempool) -> c_int;
	pub fn rte_mempool_populate_default(mp: *mut rte_mempool) -> c_int;
	pub fn rte_mempool_populate_phys(mp: *mut rte_mempool, vaddr: *mut c_char, paddr: phys_addr_t, len: size_t, free_cb: rte_mempool_memchunk_free_cb_t, opaque: *mut c_void) -> c_int;
	pub fn rte_mempool_populate_phys_tab(mp: *mut rte_mempool, vaddr: *mut c_char, paddr: *mut phys_addr_t, pg_num: uint32_t, pg_shift: uint32_t, free_cb: rte_mempool_memchunk_free_cb_t, opaque: *mut c_void) -> c_int;
	pub fn rte_mempool_populate_virt(mp: *mut rte_mempool, addr: *mut c_char, len: size_t, pg_sz: size_t, free_cb: rte_mempool_memchunk_free_cb_t, opaque: *mut c_void) -> c_int;
	pub fn rte_mempool_register_ops(ops: *const rte_mempool_ops) -> c_int;
	pub fn rte_mempool_set_ops_byname(mp: *mut rte_mempool, name: *const c_char, pool_config: *mut c_void) -> c_int;
	pub fn rte_mempool_walk(func: Option<unsafe extern "C" fn(arg1: *mut rte_mempool, arg: *mut c_void)>, arg: *mut c_void);
	pub fn rte_mempool_xmem_create(name: *const c_char, n: c_uint, elt_size: c_uint, cache_size: c_uint, private_data_size: c_uint, mp_init: rte_mempool_ctor_t, mp_init_arg: *mut c_void, obj_init: rte_mempool_obj_cb_t, obj_init_arg: *mut c_void, socket_id: c_int, flags: c_uint, vaddr: *mut c_void, paddr: *mut phys_addr_t, pg_num: uint32_t, pg_shift: uint32_t) -> *mut rte_mempool;
	pub fn rte_mempool_xmem_size(elt_num: uint32_t, total_elt_sz: size_t, pg_shift: uint32_t) -> size_t;
	pub fn rte_mempool_xmem_usage(vaddr: *mut c_void, elt_num: uint32_t, total_elt_sz: size_t, paddr: *mut phys_addr_t, pg_num: uint32_t, pg_shift: uint32_t) -> ssize_t;
	pub fn rte_memzone_dump(f: *mut FILE);
	pub fn rte_memzone_free(mz: *const rte_memzone) -> c_int;
	pub fn rte_memzone_lookup(name: *const c_char) -> *const rte_memzone;
	pub fn rte_memzone_reserve(name: *const c_char, len: size_t, socket_id: c_int, flags: c_uint) -> *const rte_memzone;
	pub fn rte_memzone_reserve_aligned(name: *const c_char, len: size_t, socket_id: c_int, flags: c_uint, align: c_uint) -> *const rte_memzone;
	pub fn rte_memzone_reserve_bounded(name: *const c_char, len: size_t, socket_id: c_int, flags: c_uint, align: c_uint, bound: c_uint) -> *const rte_memzone;
	pub fn rte_memzone_walk(func: Option<unsafe extern "C" fn(arg1: *const rte_memzone, arg: *mut c_void)>, arg: *mut c_void);
	pub fn rte_meter_srtcm_config(m: *mut rte_meter_srtcm, params: *mut rte_meter_srtcm_params) -> c_int;
	pub fn rte_meter_trtcm_config(m: *mut rte_meter_trtcm, params: *mut rte_meter_trtcm_params) -> c_int;
	pub fn rte_openlog_stream(f: *mut FILE) -> c_int;
	pub fn rte_pdump_disable(port: uint8_t, queue: uint16_t, flags: uint32_t) -> c_int;
	pub fn rte_pdump_disable_by_deviceid(device_id: *mut c_char, queue: uint16_t, flags: uint32_t) -> c_int;
	pub fn rte_pdump_enable(port: uint8_t, queue: uint16_t, flags: uint32_t, ring: *mut rte_ring, mp: *mut rte_mempool, filter: *mut c_void) -> c_int;
	pub fn rte_pdump_enable_by_deviceid(device_id: *mut c_char, queue: uint16_t, flags: uint32_t, ring: *mut rte_ring, mp: *mut rte_mempool, filter: *mut c_void) -> c_int;
	pub fn rte_pdump_init(path: *const c_char) -> c_int;
	pub fn rte_pdump_set_socket_dir(path: *const c_char, type_: rte_pdump_socktype) -> c_int;
	pub fn rte_pdump_uninit() -> c_int;
	pub fn rte_pipeline_ah_packet_drop(p: *mut rte_pipeline, pkts_mask: uint64_t) -> c_int;
	pub fn rte_pipeline_ah_packet_hijack(p: *mut rte_pipeline, pkts_mask: uint64_t) -> c_int;
	pub fn rte_pipeline_check(p: *mut rte_pipeline) -> c_int;
	pub fn rte_pipeline_create(params: *mut rte_pipeline_params) -> *mut rte_pipeline;
	pub fn rte_pipeline_flush(p: *mut rte_pipeline) -> c_int;
	pub fn rte_pipeline_free(p: *mut rte_pipeline) -> c_int;
	pub fn rte_pipeline_port_in_connect_to_table(p: *mut rte_pipeline, port_id: uint32_t, table_id: uint32_t) -> c_int;
	pub fn rte_pipeline_port_in_create(p: *mut rte_pipeline, params: *mut rte_pipeline_port_in_params, port_id: *mut uint32_t) -> c_int;
	pub fn rte_pipeline_port_in_disable(p: *mut rte_pipeline, port_id: uint32_t) -> c_int;
	pub fn rte_pipeline_port_in_enable(p: *mut rte_pipeline, port_id: uint32_t) -> c_int;
	pub fn rte_pipeline_port_in_stats_read(p: *mut rte_pipeline, port_id: uint32_t, stats: *mut rte_pipeline_port_in_stats, clear: c_int) -> c_int;
	pub fn rte_pipeline_port_out_create(p: *mut rte_pipeline, params: *mut rte_pipeline_port_out_params, port_id: *mut uint32_t) -> c_int;
	pub fn rte_pipeline_port_out_packet_insert(p: *mut rte_pipeline, port_id: uint32_t, pkt: *mut rte_mbuf) -> c_int;
	pub fn rte_pipeline_port_out_stats_read(p: *mut rte_pipeline, port_id: uint32_t, stats: *mut rte_pipeline_port_out_stats, clear: c_int) -> c_int;
	pub fn rte_pipeline_run(p: *mut rte_pipeline) -> c_int;
	pub fn rte_pipeline_table_create(p: *mut rte_pipeline, params: *mut rte_pipeline_table_params, table_id: *mut uint32_t) -> c_int;
	pub fn rte_pipeline_table_default_entry_add(p: *mut rte_pipeline, table_id: uint32_t, default_entry: *mut rte_pipeline_table_entry, default_entry_ptr: *mut *mut rte_pipeline_table_entry) -> c_int;
	pub fn rte_pipeline_table_default_entry_delete(p: *mut rte_pipeline, table_id: uint32_t, entry: *mut rte_pipeline_table_entry) -> c_int;
	pub fn rte_pipeline_table_entry_add(p: *mut rte_pipeline, table_id: uint32_t, key: *mut c_void, entry: *mut rte_pipeline_table_entry, key_found: *mut c_int, entry_ptr: *mut *mut rte_pipeline_table_entry) -> c_int;
	pub fn rte_pipeline_table_entry_add_bulk(p: *mut rte_pipeline, table_id: uint32_t, keys: *mut *mut c_void, entries: *mut *mut rte_pipeline_table_entry, n_keys: uint32_t, key_found: *mut c_int, entries_ptr: *mut *mut rte_pipeline_table_entry) -> c_int;
	pub fn rte_pipeline_table_entry_delete(p: *mut rte_pipeline, table_id: uint32_t, key: *mut c_void, key_found: *mut c_int, entry: *mut rte_pipeline_table_entry) -> c_int;
	pub fn rte_pipeline_table_entry_delete_bulk(p: *mut rte_pipeline, table_id: uint32_t, keys: *mut *mut c_void, n_keys: uint32_t, key_found: *mut c_int, entries: *mut *mut rte_pipeline_table_entry) -> c_int;
	pub fn rte_pipeline_table_stats_read(p: *mut rte_pipeline, table_id: uint32_t, stats: *mut rte_pipeline_table_stats, clear: c_int) -> c_int;
	pub fn rte_pktmbuf_dump(f: *mut FILE, m: *const rte_mbuf, dump_len: c_uint);
	pub fn rte_pktmbuf_init(mp: *mut rte_mempool, opaque_arg: *mut c_void, m: *mut c_void, i: c_uint);
	pub fn rte_pktmbuf_pool_create(name: *const c_char, n: c_uint, cache_size: c_uint, priv_size: uint16_t, data_room_size: uint16_t, socket_id: c_int) -> *mut rte_mempool;
	pub fn rte_pktmbuf_pool_init(mp: *mut rte_mempool, opaque_arg: *mut c_void);
	pub fn rte_power_exit(lcore_id: c_uint) -> c_int;
	pub fn rte_power_get_env() -> power_management_env;
	pub fn rte_power_init(lcore_id: c_uint) -> c_int;
	pub fn rte_power_set_env(env: power_management_env) -> c_int;
	pub fn rte_power_unset_env();
	pub fn rte_realloc(ptr: *mut c_void, size: size_t, align: c_uint) -> *mut c_void;
	pub fn rte_reciprocal_value(d: uint32_t) -> rte_reciprocal;
	pub fn rte_red_config_init(red_cfg: *mut rte_red_config, wq_log2: uint16_t, min_th: uint16_t, max_th: uint16_t, maxp_inv: uint16_t) -> c_int;
	pub fn rte_red_rt_data_init(red: *mut rte_red) -> c_int;
	pub fn rte_reorder_create(name: *const c_char, socket_id: c_uint, size: c_uint) -> *mut rte_reorder_buffer;
	pub fn rte_reorder_drain(b: *mut rte_reorder_buffer, mbufs: *mut *mut rte_mbuf, max_mbufs: c_uint) -> c_uint;
	pub fn rte_reorder_find_existing(name: *const c_char) -> *mut rte_reorder_buffer;
	pub fn rte_reorder_free(b: *mut rte_reorder_buffer);
	pub fn rte_reorder_init(b: *mut rte_reorder_buffer, bufsize: c_uint, name: *const c_char, size: c_uint) -> *mut rte_reorder_buffer;
	pub fn rte_reorder_insert(b: *mut rte_reorder_buffer, mbuf: *mut rte_mbuf) -> c_int;
	pub fn rte_reorder_reset(b: *mut rte_reorder_buffer);
	pub fn rte_ring_create(name: *const c_char, count: c_uint, socket_id: c_int, flags: c_uint) -> *mut rte_ring;
	pub fn rte_ring_dump(f: *mut FILE, r: *const rte_ring);
	pub fn rte_ring_free(r: *mut rte_ring);
	pub fn rte_ring_get_memsize(count: c_uint) -> ssize_t;
	pub fn rte_ring_init(r: *mut rte_ring, name: *const c_char, count: c_uint, flags: c_uint) -> c_int;
	pub fn rte_ring_list_dump(f: *mut FILE);
	pub fn rte_ring_lookup(name: *const c_char) -> *mut rte_ring;
	pub fn rte_ring_set_water_mark(r: *mut rte_ring, count: c_uint) -> c_int;
	pub fn rte_sched_pipe_config(port: *mut rte_sched_port, subport_id: uint32_t, pipe_id: uint32_t, pipe_profile: int32_t) -> c_int;
	pub fn rte_sched_port_config(params: *mut rte_sched_port_params) -> *mut rte_sched_port;
	pub fn rte_sched_port_dequeue(port: *mut rte_sched_port, pkts: *mut *mut rte_mbuf, n_pkts: uint32_t) -> c_int;
	pub fn rte_sched_port_enqueue(port: *mut rte_sched_port, pkts: *mut *mut rte_mbuf, n_pkts: uint32_t) -> c_int;
	pub fn rte_sched_port_free(port: *mut rte_sched_port);
	pub fn rte_sched_port_get_memory_footprint(params: *mut rte_sched_port_params) -> uint32_t;
	pub fn rte_sched_port_pkt_read_color(pkt: *const rte_mbuf) -> rte_meter_color;
	pub fn rte_sched_port_pkt_read_tree_path(pkt: *const rte_mbuf, subport: *mut uint32_t, pipe: *mut uint32_t, traffic_class: *mut uint32_t, queue: *mut uint32_t);
	pub fn rte_sched_port_pkt_write(pkt: *mut rte_mbuf, subport: uint32_t, pipe: uint32_t, traffic_class: uint32_t, queue: uint32_t, color: rte_meter_color);
	pub fn rte_sched_queue_read_stats(port: *mut rte_sched_port, queue_id: uint32_t, stats: *mut rte_sched_queue_stats, qlen: *mut uint16_t) -> c_int;
	pub fn rte_sched_subport_config(port: *mut rte_sched_port, subport_id: uint32_t, params: *mut rte_sched_subport_params) -> c_int;
	pub fn rte_sched_subport_read_stats(port: *mut rte_sched_port, subport_id: uint32_t, stats: *mut rte_sched_subport_stats, tc_ov: *mut uint32_t) -> c_int;
	pub fn rte_set_application_usage_hook(usage_func: rte_usage_hook_t) -> rte_usage_hook_t;
	pub fn rte_set_log_level(level: uint32_t);
	pub fn rte_set_log_type(type_: uint32_t, enable: c_int);
	pub fn rte_socket_id() -> c_uint;
	pub fn rte_strerror(errnum: c_int) -> *const c_char;
	pub fn rte_strsplit(string: *mut c_char, stringlen: c_int, tokens: *mut *mut c_char, maxtokens: c_int, delim: c_char) -> c_int;
	pub fn rte_sys_gettid() -> c_int;
	pub fn rte_thread_get_affinity(cpusetp: *mut rte_cpuset_t);
	pub fn rte_thread_set_affinity(cpusetp: *mut rte_cpuset_t) -> c_int;
	pub fn rte_thread_setname(id: pthread_t, name: *const c_char) -> c_int;
	pub fn rte_timer_dump_stats(f: *mut FILE);
	pub fn rte_timer_init(tim: *mut rte_timer);
	pub fn rte_timer_manage();
	pub fn rte_timer_pending(tim: *mut rte_timer) -> c_int;
	pub fn rte_timer_reset(tim: *mut rte_timer, ticks: uint64_t, type_: rte_timer_type, tim_lcore: c_uint, fct: rte_timer_cb_t, arg: *mut c_void) -> c_int;
	pub fn rte_timer_reset_sync(tim: *mut rte_timer, ticks: uint64_t, type_: rte_timer_type, tim_lcore: c_uint, fct: rte_timer_cb_t, arg: *mut c_void);
	pub fn rte_timer_stop(tim: *mut rte_timer) -> c_int;
	pub fn rte_timer_stop_sync(tim: *mut rte_timer);
	pub fn rte_timer_subsystem_init();
	pub fn rte_vhost_avail_entries(vid: c_int, queue_id: uint16_t) -> uint16_t;
	pub fn rte_vhost_dequeue_burst(vid: c_int, queue_id: uint16_t, mbuf_pool: *mut rte_mempool, pkts: *mut *mut rte_mbuf, count: uint16_t) -> uint16_t;
	pub fn rte_vhost_driver_callback_register(arg1: *const virtio_net_device_ops) -> c_int;
	pub fn rte_vhost_driver_register(path: *const c_char, flags: uint64_t) -> c_int;
	pub fn rte_vhost_driver_session_start() -> c_int;
	pub fn rte_vhost_driver_unregister(path: *const c_char) -> c_int;
	pub fn rte_vhost_enable_guest_notification(vid: c_int, queue_id: uint16_t, enable: c_int) -> c_int;
	pub fn rte_vhost_enqueue_burst(vid: c_int, queue_id: uint16_t, pkts: *mut *mut rte_mbuf, count: uint16_t) -> uint16_t;
	pub fn rte_vhost_feature_disable(feature_mask: uint64_t) -> c_int;
	pub fn rte_vhost_feature_enable(feature_mask: uint64_t) -> c_int;
	pub fn rte_vhost_feature_get() -> uint64_t;
	pub fn rte_vhost_get_ifname(vid: c_int, buf: *mut c_char, len: size_t) -> c_int;
	pub fn rte_vhost_get_numa_node(vid: c_int) -> c_int;
	pub fn rte_vhost_get_queue_num(vid: c_int) -> uint32_t;
	pub fn rte_zmalloc(type_: *const c_char, size: size_t, align: c_uint) -> *mut c_void;
	pub fn rte_zmalloc_socket(type_: *const c_char, size: size_t, align: c_uint, socket: c_int) -> *mut c_void;
	pub fn vt100_init(vt: *mut cmdline_vt100);
	pub fn vt100_parser(vt: *mut cmdline_vt100, c: c_char) -> c_int;
}
